import"core-js/modules/es.symbol.description";import"core-js/modules/es.symbol.replace";import"core-js/modules/es.array.iterator";import"core-js/modules/es.regexp.constructor";import"core-js/modules/es.regexp.to-string";import"core-js/modules/es.string.match";import"core-js/modules/es.string.replace";import"core-js/modules/es.string.split";import"core-js/modules/es.string.trim";import"core-js/modules/web.dom-collections.iterator";function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==="function"){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable}))}ownKeys.forEach(function(key){_defineProperty(target,key,source[key])})}return target}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}function _wrapRegExp(re,groups){_wrapRegExp=function _wrapRegExp(re,groups){return new BabelRegExp(re,groups)};var _RegExp=_wrapNativeSuper(RegExp);var _super=RegExp.prototype;var _groups=new WeakMap;function BabelRegExp(re,groups){var _this=_RegExp.call(this,re);_groups.set(_this,groups);return _this}_inherits(BabelRegExp,_RegExp);BabelRegExp.prototype.exec=function(str){var result=_super.exec.call(this,str);if(result)result.groups=buildGroups(result,this);return result};BabelRegExp.prototype[Symbol.replace]=function(str,substitution){if(typeof substitution==="string"){var groups=_groups.get(this);return _super[Symbol.replace].call(this,str,substitution.replace(/\$<([^>]+)>/g,function(_,name){return"$"+groups[name]}))}else if(typeof substitution==="function"){var _this=this;return _super[Symbol.replace].call(this,str,function(){var args=[];args.push.apply(args,arguments);if(typeof args[args.length-1]!=="object"){args.push(buildGroups(args,_this))}return substitution.apply(this,args)})}else{return _super[Symbol.replace].call(this,str,substitution)}};function buildGroups(result,re){var g=_groups.get(re);return Object.keys(g).reduce(function(groups,name){groups[name]=result[g[name]];return groups},Object.create(null))}return _wrapRegExp.apply(this,arguments)}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function")}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass)}function _possibleConstructorReturn(self,call){if(call&&(typeof call==="object"||typeof call==="function")){return call}return _assertThisInitialized(self)}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}return self}function _wrapNativeSuper(Class){var _cache=typeof Map==="function"?new Map:undefined;_wrapNativeSuper=function _wrapNativeSuper(Class){if(Class===null||!_isNativeFunction(Class))return Class;if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function")}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper)}function Wrapper(){return _construct(Class,arguments,_getPrototypeOf(this).constructor)}Wrapper.prototype=Object.create(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return _setPrototypeOf(Wrapper,Class)};return _wrapNativeSuper(Class)}function isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true}catch(e){return false}}function _construct(Parent,args,Class){if(isNativeReflectConstruct()){_construct=Reflect.construct}else{_construct=function _construct(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Function.bind.apply(Parent,a);var instance=new Constructor;if(Class)_setPrototypeOf(instance,Class.prototype);return instance}}return _construct.apply(null,arguments)}function _isNativeFunction(fn){return Function.toString.call(fn).indexOf("[native code]")!==-1}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o};return _setPrototypeOf(o,p)}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o)}import parseCustom from"./parseCustom.mjs";import parseLiteral from"./parseLiteral.mjs";import parseNotes from"./parseNotes.mjs";import parsePhonetic from"./parsePhonetic.mjs";import parseSpeaker from"./parseSpeaker.mjs";import parseTranscript from"./parseTranscript.mjs";import parseTranscription from"./parseTranscription.mjs";import parseTranslation from"./parseTranslation.mjs";import parseWords from"./parseWords.mjs";import{getCode,getLines,getSchema,mergeTranscriptions}from"../utilities/index.mjs";const lineDataRegExp=_wrapRegExp(/^\\(?:(?:[0-9A-Z_a-z]|\x2D)+)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)$/,{lineData:1});const newlineRegExp=/\r?\n/g;const wordTypes=["gl","m","w","wlt"];function createLinesHash(lines,schema){return lines.reduce((hash,line,i)=>{const code=schema[i]||"n-".concat(i);const match=line.match(lineDataRegExp);const data=(match?match.groups.lineData:line).trim();hash[code]=data;return hash},{})}export default function parseUtterance(utteranceString,schema){try{const lines=utteranceString.split(newlineRegExp).map(line=>line.trim());const codes=lines.map(getCode).filter(Boolean);if(codes.length)schema=getSchema(utteranceString);const linesHash=createLinesHash(lines,schema);const noData=!Object.values(linesHash).every(Boolean);if(noData)return null;const speaker=parseSpeaker(linesHash.sp);const transcript=parseTranscript(linesHash);let transcription=parseTranscription(linesHash);const phonetic=parsePhonetic(linesHash.phon);const literal=parseLiteral(linesHash);const translation=parseTranslation(linesHash)||"";const notes=parseNotes(linesHash);const words=parseWords(getLines(wordTypes,linesHash)||{});const custom=parseCustom(linesHash);if(!transcription){const wordTranscriptions=words.map((_ref)=>{let txn=_ref.transcription;return txn});transcription=mergeTranscriptions(wordTranscriptions," ")||""}return _objectSpread({},speaker?{speaker}:{},transcript?{transcript}:{},{transcription},phonetic?{phonetic}:{},literal?{literal}:{},{translation},notes.length?{notes}:{},words.length?{words}:{},custom)}catch(e){const utteranceText=utteranceString.split(newlineRegExp).map(str=>str.trim()).join("\n");e.name=parseUtterance.name;e.message="".concat(e.message,"\n\nUtterance text:\n\n").concat(utteranceText);throw e}}