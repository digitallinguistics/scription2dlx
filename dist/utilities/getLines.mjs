import"core-js/modules/es.symbol.description";import"core-js/modules/es.array.iterator";import"core-js/modules/es.object.from-entries";import"core-js/modules/es.string.includes";import"core-js/modules/web.dom-collections.iterator";function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i["return"]!=null)_i["return"]()}finally{if(_d)throw _e}}return _arr}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}import getLineType from"./getLineType.mjs";export default function getLines(types,lines){const wordLineEntries=Object.entries(lines).filter((_ref)=>{let _ref2=_slicedToArray(_ref,1),code=_ref2[0];return types.includes(getLineType(code))});if(!wordLineEntries.length)return null;return Object.fromEntries(wordLineEntries)}