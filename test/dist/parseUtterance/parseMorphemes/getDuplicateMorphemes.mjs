import"core-js/modules/es.symbol.description";import"core-js/modules/es.array.iterator";import"core-js/modules/web.dom-collections.iterator";function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i["return"]!=null)_i["return"]()}finally{if(_d)throw _e}}return _arr}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}import{isString}from"../../utilities/index.mjs";function getDuplicateGlosses(code,morphemes){if(!morphemes.length)return[];const glosses=morphemes.map((_ref)=>{let gloss=_ref.gloss;return code==="string"?gloss:gloss[code]});const glossCounts=glosses.reduce((counts,gl)=>{const currentCount=counts.get(gl)||0;counts.set(gl,currentCount+1);return counts},new Map);return Array.from(glossCounts.entries()).filter((_ref2)=>{let _ref3=_slicedToArray(_ref2,2),count=_ref3[1];return count>1}).map((_ref4)=>{let _ref5=_slicedToArray(_ref4,1),gl=_ref5[0];return gl})}function getFirstGlossCode(_ref6){let gloss=_ref6.gloss;const isBareString=isString(gloss);return isBareString?"string":Object.keys(gloss)[0]}export default function getDuplicateMorphemes(morphemes){const glossToCheck=getFirstGlossCode(morphemes[0]);const duplicateGlosses=getDuplicateGlosses(glossToCheck,morphemes);if(!duplicateGlosses)return[];return duplicateGlosses.map(gl=>morphemes.filter((_ref7)=>{let gloss=_ref7.gloss;if(isString(gloss))return gloss===gl;return gloss[glossToCheck]===gl}))}