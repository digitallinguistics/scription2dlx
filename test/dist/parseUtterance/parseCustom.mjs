import"core-js/modules/es.string.includes";import"core-js/modules/es.string.starts-with";function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=Object.keys(source);if(typeof Object.getOwnPropertySymbols==="function"){ownKeys=ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym){return Object.getOwnPropertyDescriptor(source,sym).enumerable}))}ownKeys.forEach(function(key){_defineProperty(target,key,source[key])})}return target}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}import{types}from"../constants/index.mjs";import{getLineType,groupLines}from"../utilities/index.mjs";const singleLines=["phon","sp"];export default function parseCustom(lines){const lineCodes=Object.keys(lines);const customTypes=lineCodes.map(getLineType).filter(type=>!types.includes(type)).reduce((hash,type)=>{hash[type]=groupLines(type,lines);return hash},{});const customCodes=lineCodes.filter(code=>{const type=getLineType(code);const isSingleLine=singleLines.includes(type);const hasSubType=code.startsWith("".concat(type,"-"));return isSingleLine&&hasSubType}).reduce((hash,code)=>{hash[code]=lines[code];return hash},{});return _objectSpread({},customCodes,customTypes)}